=encoding utf-8

=head1 NAME

perlfaq9 - Netzwerke

=head1 DESCRIPTION

Dieser Abschnitt behandelt Fragen bezüglich Netzwerken, dem Internet
und einiges über das Web.

=head2 Wie ist die korrekte Form einer Antwort von einem CGI-Skript?

(Alan Flavell <flavell+www@a5.ph.gla.ac.uk> antwortet...)

Das Common Gateway Interface (CGI) spezifiziert eine Softwareschnittstelle
zwischen einem Programm ("CGI-Skript") und einem Webserver (HTTPD). Es ist
nicht Perl-spezifisch und es seine eigenen FAQs und Tutorials und Usenet-Gruppe,
comp.infosystems.www.authoring.cgi

Die CGI-Spezifikation ist in einem informatorischem RFC skizziert:
http://www.ietf.org/rfc/rfc3875

Weiter relevante Dokumentationen sind unter http://www.perl.org/CGI_MetaFAQ.html
aufgelistet.

Diese Perl FAQs behandeln einige sehr ausgesuchte CGI-Sachen. Wieauchimmer,
Perl-Programmierer sind sehr gut beraten, das C<CGI.pm> Modul zu benutzen, das
sich um die Details für sie kümmert.

Die Ähnlichkeiten zwischen CGI-Antwort-Headern (definiert in der CGI-Spezifikation)
und HTTP-Antwort-Headern (definiert in der HTTP-Sepzifikation, RFC2616) sind
gewollt, können aber manchmal verwirrend sein.

Die CGI-Spezifikation definiert zwei Arten von Skripten: Die "Parsed Header"
Skripte und die "Non Parsed Header" (NPH) Skripte. Überprüfe die Dokumentation
Deines Servers, was er unterstützt. "Parsed Header" Skripte sind in verschiedener
Hinsicht einfacher. Die CGI-Spezifikation erlaubt alle der üblichen Darstellungen
des Zeilenumbruchs in der CGI Antwort (es ist die Aufgabe des Servers darauf basierend
eine richtige HTTP Antwort zu erzeugen). Also ist "\n" im Textmodus geschrieben 
technisch korrekt und empfohlen. NPH Skript sind kniffliger: Sie müssen einen
kompletten und fehlerfreien Satz an HTTP-Transaktions Antwort-Headern ausgeben;
die HTTP-Spezifikation verlangt, dass die Datensätze mit Carriage-Return und Line-Feed
abgeschlossen sind, z.B. ASCII \015\012 im Binärmodus geschrieben.

Die Verwendung von C<CGI.pm> bedeutet exzellente Plattformunabhängigkeit, einschließlich
EBCDIC-Systemen. C<CGI.pm> wählt die passende Zeilenumbruch-Darstellung (C<$CGI::CRLF>)
und setzt den Binärmodus wo es passt.

=head2 Mein CGI-Skript läuft von der Kommandozeile aus, aber nicht im Browser. (500 Server Error)

Verschiedene Dinge können falsch sein. Du kannst den "Troubleshooting Perl CGI Skript"-Leitfaden
unter

  http://www.perl.org/troubleshooting_CGI.html

durcharbeiten.

Wenn Du danach zeigen kannst, dass Du die FAQs gelesen hast und dass Dein Problem etwas
einfaches ist, das leicht beantwortet werden kann, wirst Du wahrscheinlinch eine nette
und hilfreiche Antwort auf Deine Frage bekommen, wenn Du sie auf comp.infosystems.www.authoring.cgi
stellst (wenn es etwas mit HTTP oder mit dem CGI-Protokoll zu tun hat). Fragen, die scheinbar Perl-Fragen
sind aber in Wirklichkeit CGI-Fragen und auf comp.lang.perl.misc gestellt werden, kommen
nicht so gut an.

Die hilfreichen FAQs, verwandte Dokumente und Leitfaden für die Fehlersuche
sind in der CGI Meta-FAQ aufgelistet:

    http://www.perl.org/CGI_MetaFAQ.html

=head2 Wie kann ich bessere Fehlermeldungen von einem CGI-Programm bekommen?

Benutze das C<CGI::Carp> Modul. Es ersetzt C<warn> und C<die> und zusätzlich
die  C<carp>-, C<croak>- und C<confess>-Funktionen aus dem normalen C<Carp> Modul
durch ausführlichere und sichere Versionen. Es schickte diese immer noch zur
normalen Fehler-Logdatei des Servers.

	use CGI::Carp;
	warn "This is a complaint";
	die "But this one is serious";

Die folgende Verwendung von C<CGI::Carp> leitet die Felhler in eine Datei Deiner Wahl um,
und ist innerhalb eines C<BEGIN>-Blocks, um auch Fehler während der Kompilier-Zeit abzufangen.

	BEGIN {
		use CGI::Carp qw(carpout);
		open(LOG, ">>/var/local/cgi-logs/mycgi-log")
			or die "Unable to append to mycgi-log: $!\n";
		carpout(*LOG);
	}

Du kannst für Schwerwiegende Fehler sogar erreichen, dass sie an den Client-Browser
zurückgehen, was für Dein eigenes Debugging schön ist, aber den Endbenutzer verwirren könnte.

	use CGI::Carp qw(fatalsToBrowser);
	die "Bad error here";

Selbst wenn der Fehler auftritt, bevor Du den HTTP-Header ausgeben konntest, wird
das Modul versuchen sich darum zu kümmern, um den gefürchteten 500 Server Error
zu vermeiden. Normale Warnungen mit dem Namen der Anwendung und Zeitstemplet vorangestellt,
landen weiterhin in der Fehler-Logdatei des Servers
(oder wo auch immer Du sie mit C<carpout> hinschickst)

=head2 Wie entferne ich HTML aus einem String?

Der korrekteste Weg (wenn auch nicht der schnellste) ist, C<HTML::Parser> vom CPAN
zu benutzen. Ein anderer weitgehend korrekter weg ist, C<HTML::FormatText> zu benutzen,
das nicht nur HTML entfernt, sondern auch ein wenig einfache Formatierung zu dem
resultierenden einfachen Text hinzuzufügen.

Viele Leute unternehmen den einfältigen Versuch mit einem einfältigen Regulären
Ausdruck, wie z.B. C<< s/<.*?>//g >>, aber das schlägt in vielen Fällen fehl, wei die
Tags vielleicht über mehrere Zeilen gehen, gequotete spitze Klammern enthalten, oder
ein HTML-Kommentar enthalten ist. Dazu vergessen die Leute Entitäten zu 
konvertieren -- wie zum Beispiel C<&lt;>.

Hier ist ein "einfältiger" Versuch, der für die meisten Dateien funktioniert:

	#!/usr/bin/perl -p0777
	s/<(?:[^>'"]*|(['"]).*?\1)*>//gs

Wenn Du eine komplettere Lösung haben willst, schau Dir das 3-stufige striphtml
Programm unter
http://www.cpan.org/authors/Tom_Christiansen/scripts/striphtml.gz
an.

Hier ein paar verzwickte Fälle, an die Du denken solltest, wenn Du eine
Lösung suchst:

	<IMG SRC = "foo.gif" ALT = "A > B">

	<IMG SRC = "foo.gif"
	 ALT = "A > B">

	<!-- <A comment> -->

	<script>if (a<b && a>c)</script>

	<# Just data #>

	<![INCLUDE CDATA [ >>>>>>>>>>>> ]]>

Wenn HTML-Kommentare andere Tags enthalten, würden die Lösungen auch an
einem Text wie diesen scheitern:

	<!-- This section commented out.
		<B>You can't see me!</B>
	-->

=head2 Wie kann ich URLs extrahieren?

Du kannst leicht alle Arten von URL aus HTML mit C<HTML::SimpleLinkExtor> herausfiltern,
das mit Ankern, Bildern, Objekten, Frames und vielen anderen Tags umgehen kann, die
eine URL enthalten können. Wenn Du etwas komplexeres benötigst, kannst Du Deine eigene
Subklasse von C<HTML::LinkExtor> oder C<HTML::Parser> schreiben. Du könntest sogar
C<HTML::SimpleLinkExtor> als Beispiel für etwas nehmen, dass speziell auf Deine
Bedürfnisse zugeschnitten ist.

Du kannst C<URI::Find> benutzen, um URLs aus einem beliebigen Text-Dokument zu filtern.

Weniger komplette Lösungen, die Reguläre Ausdrücke benutzen, können viel
Laufzeit sparen, wenn Du weißt, dass die Eingabe einfach ist. Eine Lösung von
Tom Christians läuft 100x schnelle als die meisten Modul-basierten Ansätze, filtert aber
nur die URLs von Ankern, bei denen das erste Attribut HREF ist und keine weiteren
Attribute hat.

	#!/usr/bin/perl -n00
	# qxurl - tchrist@perl.com
	print "$2\n" while m{
		< \s*
		  A \s+ HREF \s* = \s* (["']) (.*?) \1
		\s* >
	}gsix;

=head2 Wie kann ich eine Datei von der Maschine des Benutzers herunterladen? Wie kann ich eine
Datei auf einer anderen Maschine öffnen?

In diesem Fall bedeutet "herunterladen" die Datei-Upload-Funktion von HTML-Formularen
zu benutzen. Du erlaubst dem Webuser eine Datei anzugeben, die zu Deinem Webserver
geschickt werden soll. Für Dich sieht es wie ein Download aus und für den Benutzer sieht
es wie ein Upload aus. Egal wie Du es nennt, Du tust es mit etwas, das als
B<mulitpart/form-data>-Encoding bekannt ist. Das C<CGI.pm> Modul (das als Teil der Standardbibliotheken
mit Perl mitgeliefert wird) unterstützt das in der C<start_multipart_form()>-Methode, die nicht
das gleiche wie die C<startform()>-Methode ist.

Für Code-Beispiele und Details schau Dir den Abschnitt über Datei-Uploads in der C<CGI.pm>-
Dokumentation an.

=head2 Wie mache ich ein HTML Pop-Up-Menü mit Perl?

(beigetragen von brian d foy)

Das C<CGI.pm>-Module (das mit Perl mitgeliefert wird) hat Funktionen, um die HTML-Formularfelder
zu erzeugen. Schau Dir die C<CGI.pm>-Dokumentation für mehr Beispiele an.

	use CGI qw/:standard/;
	print header,
		start_html('Favorite Animals'),

		start_form,
			"What's your favorite animal? ",
		popup_menu(
			-name   => 'animal',
			-values => [ qw( Llama Alpaca Camel Ram ) ]
			),
		submit,

		end_form,
		end_html;

=head2 Wie rufe ich eine HTML-Datei ab?

(beigetragen von brian d foy)

Benutze die libwww-perl Distribution. Das Modul C<LWP::Simple> kann
Web-Ressourcen holen und Dir deren Inhalt als String zurückgeben:

	use LWP::Simple qw(get);

	my $html = get( "http://www.example.com/index.html" );

Es kann auch die Ressource direkt in einer Datei speichern:

	use LWP::Simple qw(getstore);

	getstore( "http://www.example.com/index.html", "foo.html" );

Wenn Du etwas komplizierteres machen musst, kannst Du das Modul C<LWP::UserAgent>
benutzen, um einen eigenen User-Agent (z.B. Browser) zu erstellen um die
Aufgabe zu erledigen. Wenn Du einen interaktiven Webbrowser simulieren willst,
kannst Du das Modul C<WWW::Mechanize> verwenden.

=head2 Wie kann ich HTML-Formulare automatisiert abschicken?

Wenn Du etwas komplexes machen willst, wie z.B. durch viele Seiten und
Formulare oder eine Webseite zu bewegen, kannst Du C<WWW::Mechanize>
verwenden. Schau Dir dessen Dokumentation für alle Details an.

Wenn Du Werte mit der GET-Methode abschicken willst, erstelle eine URL
und kodiere das Formular mit der C<query_form>-Methode:

	use LWP::Simple;
	use URI::URL;

	my $url = url('http://www.perl.com/cgi-bin/cpan_mod');
	$url->query_form(module => 'DB_File', readme => 1);
	$content = get($url);

Wenn Du die POST-Methode benutzt, erzeuge Dir einen eigenen User-Agent und
kodiere den Inhalt entsprechend.

	use HTTP::Request::Common qw(POST);
	use LWP::UserAgent;

	$ua = LWP::UserAgent->new();
	my $req = POST 'http://www.perl.com/cgi-bin/cpan_mod',
				   [ module => 'DB_File', readme => 1 ];
	$content = $ua->request($req)->as_string;

=head2 Wie kann ich diese %-Kodierung im Web dekodieren oder erzeugen?
X<URI> X<CGI.pm> X<CGI> X<URI::Escape> X<RFC 2396>

(beigetragen von brian d foy)

Die C<%> Kodierungen behandeln resvierte Zeichen in URIs, wie es im RFC 2396
Abschnitt 2 beschrieben ist. Diese Kodierung ersetzt das reservierte Zeichen mit
der Hexadezimalen Schreibweise der Nummer des Zeiches in der US-ASCII-Tabelle.
Zum Beispiel wird der Doppelpunkt, C<:>, zu C<%3A>.

In CGI-Skripten, brauchst Du dich um das Dekodieren der URIs kümmern, wenn Du
C<CGI.pm> benutzt. Du solltest Dich nicht selbst um die Behandlung der URI
kümmern, weder in die eine Richtung noch in die andere.

Wenn Du einen String selbst kodieren musst, denke daran, dass Du niemals versuchen
solltest eine bereits zusammengestellte URI zu kodieren. Du musst die Komponenten
einzeln escapen und danach zusammenfügen. Um einen String zu kodieren, kannst Du
das C<URI::Escape> Modul verwenden. Die C<uri_escape> Funktion liefert den
geschützten String zurück:

	my $original = "Colon : Hash # Percent %";

	my $escaped = uri_escape( $original )

	print "$escaped\n"; # 'Colon%20%3A%20Hash%20%23%20Percent%20%25%20'

Benutze die C<uri_unescape> Funktion, um den String zu dekodieren:

	my $unescaped = uri_unescape( $escaped );

	print $unescaped; # back to original

Wenn Du es selbst machen möchtest, brauchst Du nur einfach die reservierten
Zeichen mit ihrer Kodierung zu ersetzen. Eine globale Ersetzung ist ein Weg, das
zu tun:

	# encode
	$string =~ s/([^^A-Za-z0-9\-_.!~*'()])/ sprintf "%%%0x", ord $1 /eg;

	#decode
	$string =~ s/%([A-Fa-f\d]{2})/chr hex $1/eg;

=head2 Wie kann ich auf eine andere Seite weiterleiten?

Lege die komplette URL des Ziels fest (selbst wenn es auf dem gleichen Server ist).
Dies ist eine der zwei unterschiedlichen Arten von CGI "Location:" Antworten, die
in der CGI-Spezifikation für ein "Parsed Headers" Skript definiert sind. Die andere
Art (ein absoluter URL-Pfad) wird intern auf dem Server aufgelöst, ohne jede
HTTP-Weiterleitung. Die CGI-Spezifikation erlaubt in keinem dieser Fälle relative
URLs.

Die Verwendung von C<CGI.pm> ist dringend empfohlen. Dieses Beispiel zeigt die
Weiterleitung mit einer kompletten URL. Diese Weiterleitung wird durch den
Webbrowser gehandhabt.

	use CGI qw/:standard/;

	my $url = 'http://www.cpan.org/';
	print redirect($url);

Dieses Beispiel zeigt die Weiterleitung mit einem absoluten URL-Pfad. Diese
Weiterleitung wird durch den Webbrowser gehandhabt.

	my $url = '/CPAN/index.html';
	print redirect($url);

Aber direkt gecodet, könnte es wie folgt aussehen (das abschließende "\n" ist
zur Übersichtlichkeit extra angegeben) und benutzt entweder eine komplette URL
oder einen absoluten URL-Pfad.

	print "Location: $url\n";   # CGI response header
	print "\n";                 # end of headers

=head2 Wie kann ich ein Passwort auf meiner Webseite einbauen?

Um Authentifizierung für Deinen Webserver einzuschalten, musst Du Deinen
Webserver konfigurieren. Die Konfiguration ist verschieden bei den unterschiedlichen
Typen von Webservern--Apache macht es anders als iPlanet, das es anders als der IIS
macht. Prüfe Deine Webserver-Dokumentation für die Details Deines 
entsprechenden Servers.

=head2 Wie kann ich meine .htpasswd und .htgroup Dateien mit Perl bearbeiten?

Die Module C<HTTPD::UserAdmin> und C<HTTPD::GroupAdmin> bieten eine konsistente
OO Schnittstelle für diese Dateien, egal wie sie gespeichert sind. Datenbanken
können Text, DBM, Berkeley DB oder irgendeine Datenbank mit einem
DBI-kompatiblen Treiber sein. C<HTTPD::UserAdmin> unterstützt Dateien, die für
das "Basic" und "Digest" Authentifizierungs-Schema verwendet werden. Hier
ein Beispiel:

	use HTTPD::UserAdmin ();
	HTTPD::UserAdmin
	  ->new(DB => "/foo/.htpasswd")
	  ->add($username => $password);

=head2 Wie kann ich sicherstellen, dass Benutzer keine Daten eingeben können, die mein CGI-Skript böse Sachen
machen lassen?

Schau Dir die Sicherheits-Referenzen an, die in der CGI Meta FAQ aufgeführt sind

	http://www.perl.org/CGI_MetaFAQ.html

=head2 Wie kann ich einen Mail-Header parsen?

Für eine "quick-and-dirty" Lösung, probiere dies Lösung aus, die aus L<perlfunc/split>
abgeleitet ist:

	$/ = '';
	$header = <MSG>;
	$header =~ s/\n\s+/ /g;	 # merge continuation lines
	%head = ( UNIX_FROM_LINE, split /^([-\w]+):\s*/m, $header );

Diese Lösung funktioniert nicht richtig, wenn Du z.B. versuchst alle "Received"-Zeilen
zu behalten. Ein besserer Ansatz ist es, das C<Mail::Header>-Module vom CPAN (Teil
des C<MailTools> Pakets) zu benutzen.

=head2 Wie dekodiere ich ein CGI-Formular?

(beigetragen von brian d foy)

Verwende das C<CGI.pm>-Modul, das mit Perl mitgeliefert wird. Es is schnell, es
ist einfach und es macht wirklich eine ganze Menge um sicherzustellen, dass die
Dinge korrekt funktionieren. Es handhabt GET-, POST- und HEAD-Anfragen, multipart
Formulare, Felder mit mehreren Werten, Query-Strings, Nachrichtentext Kombinationen
und viele andere Dinge, über Dir Du nicht nachdenken willst.

Es geht nicht viel einfacher: Das C<CGI.pm> Modul parst automatisch die Eingabe und
macht jeden Wert über die C<param()>-Funktion verfügbar.

	use CGI qw(:standard);

	my $total = param( 'price' ) + param( 'shipping' );

	my @items = param( 'item' ); # multiple values, same field name

Wenn Du einen Objektorientierten Ansatz möchtest, kann C<CGI.pm> das auch.

	use CGI;

	my $cgi = CGI->new();

	my $total = $cgi->param( 'price' ) + $cgi->param( 'shipping' );

	my @items = $cgi->param( 'item' );

Vielleicht möchtest Du auch C<CGI::Minimal> testen, das eine leichtgewichtige Version
der gleichen Sache ist. Andere CGI::* Module auf CPAN können für Dich auch besser
funktionieren.

Viele Leute versuchen ihren eigenen Dekoder zu schreiben (oder einen von einem
anderen Programm kopieren) und laufen dann in eine der vielen "Fallen" dieser
Aufgabe. Es ist viel einfacher und weniger mühevoll, C<CGI.pm> zu verwenden.

=head2 Wie kann ich eine gültige Mail-Adresse prüfen?

(teilweise von Aaron Sherman beigetragen)

Das ist keine so einfache Frage wie sie klingt. Es gibt zwei Teile:

a) Wie überprüfe ich, dass eine Mail-Adresse korrekt formatiert ist?

b) Wie überprüfe ich, dass eine Mail-Adresse auf einen gültigen Empfänger verweist?

Ohne eine Mail an die Adresse zu schicken und zu schauen, ob ein Mensch auf der
anderen Seite Dir antwortet, kannst Du Teil I<b> nicht abschließend beantworten,
aber entweder das C<Email::Valid>- oder das C<RFC::RFC822::Address>-Modul können
sowohl Teil I<a> als auch Teil <b> machen, soweit es in real-time möglich ist.

Wenn Du nur Teil I<a> mit einem einfach Regulären Ausdruck prüfen möchtest, um zu sehen,
dass eine Adresse nach dem Mail-Header-Standard gültig ist, kannst Du Probleme bekommen,
weil es zustellbare Adresse gibt, die nicht RFC-2822-konform sind (der aktuellst
Mail-Header-Standard) und nicht-zustellbare Adressen, die konform sind. Wie auch immer,
das Folgende wird für gültige RFC-2822-Adressen passen, die keine Kommentare, 
"folding whitespaces" oder irgendwelche anderen obsoleten oder unwesentlichen
Elemente haben. Das matcht I<nur> die Adresse selbst:

	my $atom       = qr{[a-zA-Z0-9_!#\$\%&'*+/=?\^`{}~|\-]+};
	my $dot_atom   = qr{$atom(?:\.$atom)*};
	my $quoted     = qr{"(?:\\[^\r\n]|[^\\"])*"};
	my $local      = qr{(?:$dot_atom|$quoted)};
	my $quotedpair = qr{\\[\x00-\x09\x0B-\x0c\x0e-\x7e]};
	my $domain_lit = qr{\[(?:$quotedpair|[\x21-\x5a\x5e-\x7e])*\]};
 	my $domain     = qr{(?:$dot_atom|$domain_lit)};
	my $addr_spec  = qr{$local\@$domain};

Überprüfe eine Adresse einfach mit C</^${addr_spec}$/>, um zu sehen, ob sie
der RFC2822-Spezifikation folgt. Wie auch immer, weil es unmöglich ist, sicher zu
sein, dass eine solche korrekt geformte Adresse der richtige Weg ist eine 
bestimmte Person zu erreichen oder überhaupt mit einer Mailbox verbunden ist, musst
Du sehr vorsichtig sein, wie Du das nutzt.

Unser bester Hinweis für die Überprüfung der Mail-Adresse einer Person, ist, sie
ihre Adresse zweimal eingeben zu lassen, so wie Du es normalerweise machst, um ein
Passwort zu ändern. Das merzt normalerweise Tippfehler aus. Wenn beide Versionen
gleich sind, schicke eine Mail mit einer persönlichen Nachricht an diese Adresse.
Wenn Du eine Nachricht zurückbekommst und sie Deinen Anweisungen gefolgt sind,
kannst Du einigermaßen sicher sein, dass die Adresse real ist.

Eine verwandte Strategie, die weniger anfällig für Missbrauch ist, ist, ihnen eine
PIN (Persönliche ID Nummer) zu geben. Speichere die Adresse und die PIN (am Besten
ist sie eine zufällige Nummer) für die spätere Bearbeitung. In der Nachricht, die
Du ihnen schickst, forderst Du sie auf, die PIN in ihrer Antwort anzugeben. Wenn die
Mail aber zurückkommt oder in einer Abwesenheitsnotiz enthalten ist, wird die PIN
auch vorhanden sein. Also ist es das Beste, eine leicht veränderte Version der PIN
zurück zu mailen, z.B. mit den Zeichen in umgekehrter Reihenfolge, oder zu jeder
Zahl eins hinzuaddiert oder subtrahiert, etc.

=head2 How do I decode a MIME/BASE64 string?

The MIME-Base64 package (available from CPAN) handles this as well as
the MIME/QP encoding.  Decoding BASE64 becomes as simple as:

	use MIME::Base64;
	$decoded = decode_base64($encoded);

The MIME-Tools package (available from CPAN) supports extraction with
decoding of BASE64 encoded attachments and content directly from email
messages.

If the string to decode is short (less than 84 bytes long)
a more direct approach is to use the unpack() function's "u"
format after minor transliterations:

	tr#A-Za-z0-9+/##cd;                   # remove non-base64 chars
	tr#A-Za-z0-9+/# -_#;                  # convert to uuencoded format
	$len = pack("c", 32 + 0.75*length);   # compute length byte
	print unpack("u", $len . $_);         # uudecode and print

=head2 How do I return the user's mail address?

On systems that support getpwuid, the $< variable, and the
Sys::Hostname module (which is part of the standard perl distribution),
you can probably try using something like this:

	use Sys::Hostname;
	$address = sprintf('%s@%s', scalar getpwuid($<), hostname);

Company policies on mail address can mean that this generates addresses
that the company's mail system will not accept, so you should ask for
users' mail addresses when this matters.  Furthermore, not all systems
on which Perl runs are so forthcoming with this information as is Unix.

The Mail::Util module from CPAN (part of the MailTools package) provides a
mailaddress() function that tries to guess the mail address of the user.
It makes a more intelligent guess than the code above, using information
given when the module was installed, but it could still be incorrect.
Again, the best way is often just to ask the user.

=head2 How do I send mail?

Use the C<sendmail> program directly:

	open(SENDMAIL, "|/usr/lib/sendmail -oi -t -odq")
		or die "Can't fork for sendmail: $!\n";
	print SENDMAIL <<"EOF";
	From: User Originating Mail <me\@host>
	To: Final Destination <you\@otherhost>
	Subject: A relevant subject line

	Body of the message goes here after the blank line
	in as many lines as you like.
	EOF
	close(SENDMAIL)     or warn "sendmail didn't close nicely";

The B<-oi> option prevents sendmail from interpreting a line consisting
of a single dot as "end of message".  The B<-t> option says to use the
headers to decide who to send the message to, and B<-odq> says to put
the message into the queue.  This last option means your message won't
be immediately delivered, so leave it out if you want immediate
delivery.

Alternate, less convenient approaches include calling mail (sometimes
called mailx) directly or simply opening up port 25 have having an
intimate conversation between just you and the remote SMTP daemon,
probably sendmail.

Or you might be able use the CPAN module Mail::Mailer:

	use Mail::Mailer;

	$mailer = Mail::Mailer->new();
	$mailer->open({ From    => $from_address,
					To      => $to_address,
					Subject => $subject,
				  })
		or die "Can't open: $!\n";
	print $mailer $body;
	$mailer->close();

The Mail::Internet module uses Net::SMTP which is less Unix-centric than
Mail::Mailer, but less reliable.  Avoid raw SMTP commands.  There
are many reasons to use a mail transport agent like sendmail.  These
include queuing, MX records, and security.

=head2 How do I use MIME to make an attachment to a mail message?

This answer is extracted directly from the MIME::Lite documentation.
Create a multipart message (i.e., one with attachments).

	use MIME::Lite;

	### Create a new multipart message:
	$msg = MIME::Lite->new(
				 From    =>'me@myhost.com',
				 To      =>'you@yourhost.com',
				 Cc      =>'some@other.com, some@more.com',
				 Subject =>'A message with 2 parts...',
				 Type    =>'multipart/mixed'
				 );

	### Add parts (each "attach" has same arguments as "new"):
	$msg->attach(Type     =>'TEXT',
				 Data     =>"Here's the GIF file you wanted"
				 );
	$msg->attach(Type     =>'image/gif',
				 Path     =>'aaa000123.gif',
				 Filename =>'logo.gif'
				 );

	$text = $msg->as_string;

MIME::Lite also includes a method for sending these things.

	$msg->send;

This defaults to using L<sendmail> but can be customized to use
SMTP via L<Net::SMTP>.

=head2 How do I read mail?

While you could use the Mail::Folder module from CPAN (part of the
MailFolder package) or the Mail::Internet module from CPAN (part
of the MailTools package), often a module is overkill.  Here's a
mail sorter.

	#!/usr/bin/perl

	my(@msgs, @sub);
	my $msgno = -1;
	$/ = '';                    # paragraph reads
	while (<>) {
		if (/^From /m) {
			/^Subject:\s*(?:Re:\s*)*(.*)/mi;
			$sub[++$msgno] = lc($1) || '';
		}
		$msgs[$msgno] .= $_;
	}
	for my $i (sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msgs)) {
		print $msgs[$i];
	}

Or more succinctly,

	#!/usr/bin/perl -n00
	# bysub2 - awkish sort-by-subject
	BEGIN { $msgno = -1 }
	$sub[++$msgno] = (/^Subject:\s*(?:Re:\s*)*(.*)/mi)[0] if /^From/m;
	$msg[$msgno] .= $_;
	END { print @msg[ sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msg) ] }

=head2 Wie kann ich meinen Hostnamen, Domainnamen oder IP-Adresse herausfinden?
X<hostname, domainname, IP address, host, domain, hostfqdn, inet_ntoa,
gethostbyname, Socket, Net::Domain, Sys::Hostname>

(beigetragen von brian d foy)

The Net::Domain module, which is part of the standard distribution starting
in perl5.7.3, can get you the fully qualified domain name (FQDN), the host
name, or the domain name.

	use Net::Domain qw(hostname hostfqdn hostdomain);

	my $host = hostfqdn();

The C<Sys::Hostname> module, included in the standard distribution since
perl5.6, can also get the hostname.

	use Sys::Hostname;

	$host = hostname();

To get the IP address, you can use the C<gethostbyname> built-in function
to turn the name into a number. To turn that number into the dotted octet
form (a.b.c.d) that most people expect, use the C<inet_ntoa> function
from the <Socket> module, which also comes with perl.

	use Socket;

	my $address = inet_ntoa(
		scalar gethostbyname( $host || 'localhost' )
		);

=head2 Wie kann ich einen News-Artikel oder die aktive Newsgroup holen?

Benutze das Net::NNTP- oder News::NNTPClient-Modul, die es beide auf dem
CPAN gibt. Das macht Aufgabe wie das holen der Newsgroup-Liste so einfach wie

	perl -MNews::NNTPClient
	  -e 'print News::NNTPClient->new->list("newsgroups")'

=head2 Wie kann ich eine Datei per FTP holen/hochladen?

LWP::Simple (auf dem CPAN verfügbar) kann Dateien holen aber nicht hochladen.
Net::FTP (ebenfalls auf dem CPAN verfügbar) is komplexer kann aber sowohl Dateien
hochladen als auch holen.

=head2 Wie kann ich RPC in Perl verwenden?

(beigetragen von brian d foy)

Benutze eines der RPC-Module, die Du auf CPAN finden kannst (
http://search.cpan.org/search?query=RPC&mode=all ).

=head1 REVISION

Revision: $Revision$

Datum: $Date$

Für Details über Versionskontrolle und Verfügbarkeit siehe L<perlfaq>.

=head1 AUTOR UND COPYRIGHT

Copyright (c) 1997-2009 Tom Christiansen, Nathan Torkington und andere
Autoren wie genannt. Alle Rechte vorbehalten.

Diese Dokument ist frei; Du kannst es unter den gleichen Bedingungen wie
Perl selbst weiterverteilen und/oder verändern.

Unabhängig von der Verteilung, sind alle Code-Beispiele Gemeingut. Dir wird 
erlaubt und du wirst ermutigt, sie und beliebige davon abgeleitete in deinen 
Programmen zum Spaß oder für Profit zu verwenden. 
Ein einfacher Kommentar im Code, der die FAQ würdigt, wäre nett, ist aber 
nicht erforderlich. 

Übersetzung von Renée Bäcker
