=head1 NAME

perlfaq9 - Netzwerke

=head1 DESCRIPTION

Dieser Abschnitt behandelt Fragen bezüglich Netzwerken, dem Internet
und einiges über das Web.

=head2 Wie ist die korrekte Form einer Antwort von einem CGI-Skript?

(Alan Flavell <flavell+www@a5.ph.gla.ac.uk> antwortet...)

Das Common Gateway Interface (CGI) spezifiziert eine Softwareschnittstelle
zwischen einem Programm ("CGI-Skript") und einem Webserver (HTTPD). Es ist
nicht Perl-spezifisch und es seine eigenen FAQs und Tutorials und Usenet-Gruppe,
comp.infosystems.www.authoring.cgi

Die CGI-Spezifikation ist in einem informatorischem RFC skizziert:
http://www.ietf.org/rfc/rfc3875

Weiter relevante Dokumentationen sind unter http://www.perl.org/CGI_MetaFAQ.html
aufgelistet.

Diese Perl FAQs behandeln einige sehr ausgesuchte CGI-Sachen. Wieauchimmer,
Perl-Programmierer sind sehr gut beraten, das CGI.pm Module zu benutzen, das
sich um die Details für sie kümmert.

Die Ähnlichkeiten zwischen CGI-Antwort-Headern (definiert in der CGI-Spezifikation)
und HTTP-Antwort-Headern (definiert in der HTTP-Sepzifikation, RFC2616) sind
gewollt, können aber manchmal verwirrend sein.

Die CGI-Spezifikation definiert zwei Arten von Skripten: Die "Parsed Header"
Skripte und die "Non Parsed Header" (NPH) Skripte. Überprüfe die Dokumentation
Deines Servers, was er unterstützt. "Parsed Header" Skripte sind in verschiedener
Hinsicht einfacher. Die CGI-Spezifikation erlaubt alle der üblichen Darstellungen
des Zeilenumbruchs in der CGI Antwort (es ist die Aufgabe des Servers darauf basierend
eine richtige HTTP Antwort zu erzeugen). Also ist "\n" im Textmodus geschrieben 
technisch korrekt und empfohlen. NPH Skript sind kniffliger: Sie müssen einen
kompletten und fehlerfreien Satz an HTTP-Transaktions Antwort-Headern ausgeben;
die HTTP-Spezifikation verlangt, dass die Datensätze mit Carriage-Return und Line-Feed
abgeschlossen sind, z.B. ASCII \015\012 im Binärmodus geschrieben.

Die Verwendung von CGI.pm bedeutet exzellente Plattformunabhängigkeit, einschließlich
EBCDIC-Systemen. CGI.pm wählt die passende Zeilenumbruch-Darstellung ($CGI::CRLF)
und setzt den Binärmodus wo es passt.

=head2 Mein CGI-Skript läuft von der Kommandozeile aus, aber nicht im Browser. (500 Server Error)

Verschiedene Dinge können falsch sein. Du kannst den "Troubleshooting Perl CGI Skript"-Leitfaden
unter

  http://www.perl.org/troubleshooting_CGI.html

durcharbeiten.

Wenn Du danach zeigen kannst, dass Du die FAQs gelesen hast und dass Dein Problem etwas
einfaches ist, das leicht beantwortet werden kann, wirst Du wahrscheinlinch eine nette
und hilfreiche Antwort auf Deine Frage bekommen, wenn Du sie auf comp.infosystems.www.authoring.cgi
stellst (wenn es etwas mit HTTP oder mit dem CGI-Protokoll zu tun hat). Fragen, die scheinbar Perl-Fragen
sind aber in Wirklichkeit CGI-Fragen und auf comp.lang.perl.misc gestellt werden, kommen
nicht so gut an.

Die hilfreichen FAQs, verwandte Dokumente und Leitfaden für die Fehlersuche
sind in der CGI Meta-FAQ aufgelistet:

    http://www.perl.org/CGI_MetaFAQ.html

=head2 Wie kann ich bessere Fehlermeldungen von einem CGI-Programm bekommen?

Benutze das CGI::Carp Modul. Es ersetzt C<warn> und C<die> und zusätzlich
die  C<carp>-, C<croak>- und C<confess>-Funktionen aus dem normalen Carp Modul
durch ausführlichere und sichere Versionen. Es schickte diese immer noch zur
normalen Fehler-Logdatei des Servers.

	use CGI::Carp;
	warn "This is a complaint";
	die "But this one is serious";

Die folgende Verwendung von CGI::Carp leitet die Felhler in eine Datei Deiner Wahl um,
und ist innerhalb eines BEGIN blocks, um auch Fehler während der Kompilier-Zeit abzufangen.

	BEGIN {
		use CGI::Carp qw(carpout);
		open(LOG, ">>/var/local/cgi-logs/mycgi-log")
			or die "Unable to append to mycgi-log: $!\n";
		carpout(*LOG);
	}

Du kannst für Schwerwiegende Fehler sogar erreichen, dass sie an den Client-Browser
zurückgehen, was für Dein eigenes Debugging schön ist, aber den Endbenutzer verwirren könnte.

	use CGI::Carp qw(fatalsToBrowser);
	die "Bad error here";

Selbst wenn der Fehler auftritt, bevor Du den HTTP-Header ausgeben konntest, wird
das Modul versuchen sich darum zu kümmern, um den gefürchteten 500 Server Error
zu vermeiden. Normale Warnungen mit dem Namen der Anwendung und Zeitstemplet vorangestellt,
landen weiterhin in der Fehler-Logdatei des Servers
(oder wo auch immer Du sie mit C<carpout> hinschickst)

=head2 Wie entferne ich HTML aus einem String?

Der korrekteste Weg (wenn auch nicht der schnellste) ist, HTML::Parser vom CPAN
zu benutzen. Ein anderer weitgehend korrekter weg ist, HTML::FormatText zu benutzen,
das nicht nur HTML entfernt, sondern auch ein wenig einfache Formatierung zu dem
resultierenden einfachen Text hinzuzufügen.

Viele Leute unternehmen den einfältigen Versuch mit einem einfältigen Regulären
Ausdruck, wie z.B. C<< s/<.*?>//g >>, aber das schlägt in vielen Fällen fehl, wei die
Tags vielleicht über mehrere Zeilen gehen, gequotete spitze Klammern enthalten, oder
ein HTML-Kommentar enthalten ist. Dazu vergessen die Leute Entitäten zu 
konvertieren -- wie zum Beispiel C<&lt;>.

Hier ist ein "einfältiger" Versuch, der für die meisten Dateien funktioniert:

	#!/usr/bin/perl -p0777
	s/<(?:[^>'"]*|(['"]).*?\1)*>//gs

Wenn Du eine komplettere Lösung haben willst, schau Dir das 3-stufige striphtml
Programm unter
http://www.cpan.org/authors/Tom_Christiansen/scripts/striphtml.gz
an.

Hier ein paar verzwickte Fälle, an die Du denken solltest, wenn Du eine
Lösung suchst:

	<IMG SRC = "foo.gif" ALT = "A > B">

	<IMG SRC = "foo.gif"
	 ALT = "A > B">

	<!-- <A comment> -->

	<script>if (a<b && a>c)</script>

	<# Just data #>

	<![INCLUDE CDATA [ >>>>>>>>>>>> ]]>

Wenn HTML-Kommentare andere Tags enthalten, würden die Lösungen auch an
einem Text wie diesen scheitern:

	<!-- This section commented out.
		<B>You can't see me!</B>
	-->

=head2 Wie kann ich URLs extrahieren?

Du kannst leicht alle Arten von URL aus HTML mit C<HTML::SimpleLinkExtor> herausfiltern,
das mit Ankern, Bildern, Objekten, Frames und vielen anderen Tags umgehen kann, die
eine URL enthalten können. Wenn Du etwas komplexeres benötigst, kannst Du Deine eigene
Subklasse von C<HTML::LinkExtor> oder C<HTML::Parser> schreiben. Du könntest sogar
C<HTML::SimpleLinkExtor> als Beispiel für etwas nehmen, dass speziell auf Deine
Bedürfnisse zugeschnitten ist.

Du kannst URI::Find benutzen, um URLs aus einem beliebigen Text-Dokument zu filtern.

Weniger komplette Lösungen, die Reguläre Ausdrücke benutzen, können viel
Laufzeit sparen, wenn Du weißt, dass die Eingabe einfach ist. Eine Lösung von
Tom Christians läuft 100x schnelle als die meisten Modul-basierten Ansätze, filtert aber
nur die URLs von Ankern, bei denen das erste Attribut HREF ist und keine weiteren
Attribute hat.

	#!/usr/bin/perl -n00
	# qxurl - tchrist@perl.com
	print "$2\n" while m{
		< \s*
		  A \s+ HREF \s* = \s* (["']) (.*?) \1
		\s* >
	}gsix;

=head2 Wie kann ich eine Datei von der Maschine des Benutzers herunterladen? Wie kann ich eine
Datei auf einer anderen Maschine öffnen?

In diesem Fall bedeutet "herunterladen" die Datei-Upload-Funktion von HTML-Formularen
zu benutzen. Du erlaubst dem Webuser eine Datei anzugeben, die zu Deinem Webserver
geschickt werden soll. Für Dich sieht es wie ein Download aus und für den Benutzer sieht
es wie ein Upload aus. Egal wie Du es nennt, Du tust es mit etwas, das als
B<mulitpart/form-data>-Encoding bekannt ist. Das CGI.pm Modul (das als Teil der Standardbibliotheken
mit Perl mitgeliefert wird) unterstützt das in der start_multipart_form()-Methode, die nicht
das gleiche wie die startform()-Methode ist.

Für Code-Beispiele und Details schau Dir den Abschnitt über Datei-Uploads in der CGI.pm-
Dokumentation an.

=head2 Wie mache ich ein HTML Pop-Up-Menü mit Perl?

(beigetragen von brian d foy)

Das CGI.pm-Module (das mit Perl migeliefert wird) hat Funktionen, um die HTML-Formularfelder
zu erzeugen. Schau Dir die CGI.pm-Dokumentation für mehr Beispiele an.

	use CGI qw/:standard/;
	print header,
		start_html('Favorite Animals'),

		start_form,
			"What's your favorite animal? ",
		popup_menu(
			-name   => 'animal',
			-values => [ qw( Llama Alpaca Camel Ram ) ]
			),
		submit,

		end_form,
		end_html;

=head2 Wie rufe ich eine HTML-Datei ab?

(beigetragen von brian d foy)

Benutze die libwww-perl Distribution. Das Modul C<LWP::Simple> kann
Web-Ressourcen hoen und Dir deren Inhalt als String zurückgeben:

	use LWP::Simple qw(get);

	my $html = get( "http://www.example.com/index.html" );

Es kann auch die Ressouce direkt in einer Datei speichern:

	use LWP::Simple qw(getstore);

	getstore( "http://www.example.com/index.html", "foo.html" );

Wenn Du etwas komplizierteres machen musst, kannst Du das Modul C<LWP::UserAgent>
benutzen, um einen eigenen User-Agent (z.B. Browser) zu erstellen um die
Aufgabe zu erledigen. Wenn Du einen interaktiven Webbrowser simulieren willst,
kannst Du das Modul C<WWW::Mechanize> verwenden.

=head2 Wie kann ich HTML-Formulare automatisiert abschicken?

Wenn Du etwas komplexes machen willst, wie z.B. durch viele Seiten und
Formulare oder eine Webseite zu bewegen, kannst Du C<WWW::Mechanize>
verwenden. Schau Dir dessen Dokumentation für alle Details an.

Wenn Du Werte mit der GET-Methode abschicken willst, erstelle eine URL
und kodiere das Formular mit der C<query_form>-Methode:

	use LWP::Simple;
	use URI::URL;

	my $url = url('http://www.perl.com/cgi-bin/cpan_mod');
	$url->query_form(module => 'DB_File', readme => 1);
	$content = get($url);

Wenn Du die POST-Methode benutzt, erzeuge Dir einen eigenen User-Agent und
kodiere den Inhalt entsprechend.

	use HTTP::Request::Common qw(POST);
	use LWP::UserAgent;

	$ua = LWP::UserAgent->new();
	my $req = POST 'http://www.perl.com/cgi-bin/cpan_mod',
				   [ module => 'DB_File', readme => 1 ];
	$content = $ua->request($req)->as_string;

=head2 Wie kann ich diese %-Kodierung im Web dekodieren oder erzeugen?
X<URI> X<CGI.pm> X<CGI> X<URI::Escape> X<RFC 2396>

(beigetragen von brian d foy)

Die C<%> Kodierungen behandeln resvierte Zeichen in URIs, wie es im RFC 2396
Abschnitt 2 beschrieben ist. Diese Kodierung ersetzt das reservierte Zeichen mit
der Hexadezimalen Schreibweise der Nummer des Zeiches in der US-ASCII-Tabelle.
Zum Beispiel wird der Doppelpunkt, C<:>, zu C<%3A>.

In CGI-Skripten, brauchst Du dich um das Dekodieren der URIs kümmern, wenn Du
C<CGI.pm> benutzt. Du solltest Dich nicht selbst um die Behandlung der URI
kümmern, weder in die eine Richtung noch in die andere.

Wenn Du einen String selbst kodieren musst, denke daran, dass Du niemals versuchen
solltest eine bereits zusammengestellte URI zu kodieren. Du musst die Komponenten
einzeln escapen und danach zusammenfügen. Um einen String zu kodieren, kannst Du
das C<URI::Escape> Modul verwenden. Die C<uri_escape> Funktion liefert den
geschützten String zurück:

	my $original = "Colon : Hash # Percent %";

	my $escaped = uri_escape( $original )

	print "$escaped\n"; # 'Colon%20%3A%20Hash%20%23%20Percent%20%25%20'

Benutze die C<uri_unescape> Funktion, um den String zu dekodieren:

	my $unescaped = uri_unescape( $escaped );

	print $unescaped; # back to original

Wenn Du es selbst machen möchtest, brauchst Du nur einfach die reservierten
Zeichen mit ihrer Kodierung zu ersetzen. Eine globale Ersetzung ist ein Weg, das
zu tun:

	# encode
	$string =~ s/([^^A-Za-z0-9\-_.!~*'()])/ sprintf "%%%0x", ord $1 /eg;

	#decode
	$string =~ s/%([A-Fa-f\d]{2})/chr hex $1/eg;

=head2 Wie kann ich auf eine andere Seite weiterleiten?

Lege die komplette URL des Ziels fest (selbst wenn es auf dem gleichen Server ist).
Dies ist eine der zwei unterschiedlichen Arten von CGI "Location:" Antworten, die
in der CGI-Spezifikation für ein "Parsed Headers" Skript definiert sind. Die andere
Art (ein absoluter URL-Pfad) wird intern auf dem Server aufgelöst, ohne jede
HTTP-Weiterleitung. Die CGI-Spezifikation erlaubt in keinem dieser Fälle relative
URLs.

Die Verwendung von C<CGI.pm> ist dringend empfohlen. Dieses Beispiel zeigt die
Weiterleitung mit einer kompletten URL. Diese Weiterleitung wird durch den
Webbrowser gehandhabt.

	use CGI qw/:standard/;

	my $url = 'http://www.cpan.org/';
	print redirect($url);

Dieses Beispiel zeigt die Weiterleitung mit einem absoluten URL-PFad. Diese
Weiterleitung wird durch den Webbrowser gehandhabt.

	my $url = '/CPAN/index.html';
	print redirect($url);

Aber direkt gecodet, könnte es wie folgt aussehen (das abschließende "\n" ist
zur Übersichtlichkeit extra angegeben) und benutzt entweder eine komplette URL
oder einen absoluten URL-Pfad.

	print "Location: $url\n";   # CGI response header
	print "\n";                 # end of headers

=head2 Wie kann ich ein Passwort auf meiner Webseite einbauen?

Um Authentifizierung für Deinen Webserver einzuschalten, musst Du Deinen
Webserver konfigurieren. Die Konfiguration ist verschieden bei den unterschiedlichen
Typen von Webservern--Apache macht es anders als iPlanet, das es anders als der IIS
macht. Prüfe Deine Webserver-Dokumentation für die Details Deines 
entsprechenden Servers.

=head2 Wie kann ich meine .htpasswd und .htgroup Dateien mit Perl bearbeiten?

Die Module HTTPD::UserAdmin und HTTPD::GroupAdmin bieten eine konsistente
OO Schnittstelle für diese Dateien, egal wie sie gespeichert sind. Datenbanken
können Text, DBM, Berkeley DB oder irgendeine Datenbank mit einem
DBI-kompatiblen Treiber sein. HTTPD::UserAdmin unterstützt Dateien, die für
das "Basic" und "Digest" Authentifizierungs-Schema verwendet werden. Hier
ein Beispiel:

	use HTTPD::UserAdmin ();
	HTTPD::UserAdmin
	  ->new(DB => "/foo/.htpasswd")
	  ->add($username => $password);

=head2 Wie kann ich sicherstellen, dass Benutzer keine Daten eingeben können, die mein CGI-Skript böse Sachen
machen lassen?

Schau Dir die Sicherheits-Referenzen an, die in der CGI Meta FAQ aufgeführt sind

	http://www.perl.org/CGI_MetaFAQ.html

=head2 Wie kann ich einen Mail-Header parsen?

Für eine "quick-and-dirty" Lösung, probiere dies Lösung aus, die aus L<perlfunc/split>
abgeleitet ist:

	$/ = '';
	$header = <MSG>;
	$header =~ s/\n\s+/ /g;	 # merge continuation lines
	%head = ( UNIX_FROM_LINE, split /^([-\w]+):\s*/m, $header );

Diese Lösung funktioniert nicht richtig, wenn Du z.B. versuchst alle "Received"-Zeilen
zu behalten. Ein besserer Ansatz ist es, das C<Mail::Header>-Module vom CPAN (Teil
des C<MailTools> Pakets) zu benutzen.

=head2 How do I decode a CGI form?

(contributed by brian d foy)

Use the CGI.pm module that comes with Perl.  It's quick,
it's easy, and it actually does quite a bit of work to
ensure things happen correctly.  It handles GET, POST, and
HEAD requests, multipart forms, multivalued fields, query
string and message body combinations, and many other things
you probably don't want to think about.

It doesn't get much easier: the CGI module automatically
parses the input and makes each value available through the
C<param()> function.

	use CGI qw(:standard);

	my $total = param( 'price' ) + param( 'shipping' );

	my @items = param( 'item' ); # multiple values, same field name

If you want an object-oriented approach, CGI.pm can do that too.

	use CGI;

	my $cgi = CGI->new();

	my $total = $cgi->param( 'price' ) + $cgi->param( 'shipping' );

	my @items = $cgi->param( 'item' );

You might also try CGI::Minimal which is a lightweight version
of the same thing.  Other CGI::* modules on CPAN might work better
for you, too.

Many people try to write their own decoder (or copy one from
another program) and then run into one of the many "gotchas"
of the task.  It's much easier and less hassle to use CGI.pm.

=head2 How do I check a valid mail address?

(partly contributed by Aaron Sherman)

This isn't as simple a question as it sounds.  There are two parts:

a) How do I verify that an email address is correctly formatted?

b) How do I verify that an email address targets a valid recipient?

Without sending mail to the address and seeing whether there's a human
on the other end to answer you, you cannot fully answer part I<b>, but
either the C<Email::Valid> or the C<RFC::RFC822::Address> module will do
both part I<a> and part I<b> as far as you can in real-time.

If you want to just check part I<a> to see that the address is valid
according to the mail header standard with a simple regular expression,
you can have problems, because there are deliverable addresses that
aren't RFC-2822 (the latest mail header standard) compliant, and
addresses that aren't deliverable which, are compliant.  However,  the
following will match valid RFC-2822 addresses that do not have comments,
folding whitespace, or any other obsolete or non-essential elements.
This I<just> matches the address itself:

	my $atom       = qr{[a-zA-Z0-9_!#\$\%&'*+/=?\^`{}~|\-]+};
	my $dot_atom   = qr{$atom(?:\.$atom)*};
	my $quoted     = qr{"(?:\\[^\r\n]|[^\\"])*"};
	my $local      = qr{(?:$dot_atom|$quoted)};
	my $quotedpair = qr{\\[\x00-\x09\x0B-\x0c\x0e-\x7e]};
	my $domain_lit = qr{\[(?:$quotedpair|[\x21-\x5a\x5e-\x7e])*\]};
 	my $domain     = qr{(?:$dot_atom|$domain_lit)};
	my $addr_spec  = qr{$local\@$domain};

Just match an address against C</^${addr_spec}$/> to see if it follows
the RFC2822 specification.  However, because it is impossible to be
sure that such a correctly formed address is actually the correct way
to reach a particular person or even has a mailbox associated with it,
you must be very careful about how you use this.

Our best advice for verifying a person's mail address is to have them
enter their address twice, just as you normally do to change a
password. This usually weeds out typos. If both versions match, send
mail to that address with a personal message. If you get the message
back and they've followed your directions, you can be reasonably
assured that it's real.

A related strategy that's less open to forgery is to give them a PIN
(personal ID number).  Record the address and PIN (best that it be a
random one) for later processing. In the mail you send, ask them to
include the PIN in their reply.  But if it bounces, or the message is
included via a "vacation" script, it'll be there anyway.  So it's
best to ask them to mail back a slight alteration of the PIN, such as
with the characters reversed, one added or subtracted to each digit, etc.

=head2 How do I decode a MIME/BASE64 string?

The MIME-Base64 package (available from CPAN) handles this as well as
the MIME/QP encoding.  Decoding BASE64 becomes as simple as:

	use MIME::Base64;
	$decoded = decode_base64($encoded);

The MIME-Tools package (available from CPAN) supports extraction with
decoding of BASE64 encoded attachments and content directly from email
messages.

If the string to decode is short (less than 84 bytes long)
a more direct approach is to use the unpack() function's "u"
format after minor transliterations:

	tr#A-Za-z0-9+/##cd;                   # remove non-base64 chars
	tr#A-Za-z0-9+/# -_#;                  # convert to uuencoded format
	$len = pack("c", 32 + 0.75*length);   # compute length byte
	print unpack("u", $len . $_);         # uudecode and print

=head2 How do I return the user's mail address?

On systems that support getpwuid, the $< variable, and the
Sys::Hostname module (which is part of the standard perl distribution),
you can probably try using something like this:

	use Sys::Hostname;
	$address = sprintf('%s@%s', scalar getpwuid($<), hostname);

Company policies on mail address can mean that this generates addresses
that the company's mail system will not accept, so you should ask for
users' mail addresses when this matters.  Furthermore, not all systems
on which Perl runs are so forthcoming with this information as is Unix.

The Mail::Util module from CPAN (part of the MailTools package) provides a
mailaddress() function that tries to guess the mail address of the user.
It makes a more intelligent guess than the code above, using information
given when the module was installed, but it could still be incorrect.
Again, the best way is often just to ask the user.

=head2 How do I send mail?

Use the C<sendmail> program directly:

	open(SENDMAIL, "|/usr/lib/sendmail -oi -t -odq")
		or die "Can't fork for sendmail: $!\n";
	print SENDMAIL <<"EOF";
	From: User Originating Mail <me\@host>
	To: Final Destination <you\@otherhost>
	Subject: A relevant subject line

	Body of the message goes here after the blank line
	in as many lines as you like.
	EOF
	close(SENDMAIL)     or warn "sendmail didn't close nicely";

The B<-oi> option prevents sendmail from interpreting a line consisting
of a single dot as "end of message".  The B<-t> option says to use the
headers to decide who to send the message to, and B<-odq> says to put
the message into the queue.  This last option means your message won't
be immediately delivered, so leave it out if you want immediate
delivery.

Alternate, less convenient approaches include calling mail (sometimes
called mailx) directly or simply opening up port 25 have having an
intimate conversation between just you and the remote SMTP daemon,
probably sendmail.

Or you might be able use the CPAN module Mail::Mailer:

	use Mail::Mailer;

	$mailer = Mail::Mailer->new();
	$mailer->open({ From    => $from_address,
					To      => $to_address,
					Subject => $subject,
				  })
		or die "Can't open: $!\n";
	print $mailer $body;
	$mailer->close();

The Mail::Internet module uses Net::SMTP which is less Unix-centric than
Mail::Mailer, but less reliable.  Avoid raw SMTP commands.  There
are many reasons to use a mail transport agent like sendmail.  These
include queuing, MX records, and security.

=head2 How do I use MIME to make an attachment to a mail message?

This answer is extracted directly from the MIME::Lite documentation.
Create a multipart message (i.e., one with attachments).

	use MIME::Lite;

	### Create a new multipart message:
	$msg = MIME::Lite->new(
				 From    =>'me@myhost.com',
				 To      =>'you@yourhost.com',
				 Cc      =>'some@other.com, some@more.com',
				 Subject =>'A message with 2 parts...',
				 Type    =>'multipart/mixed'
				 );

	### Add parts (each "attach" has same arguments as "new"):
	$msg->attach(Type     =>'TEXT',
				 Data     =>"Here's the GIF file you wanted"
				 );
	$msg->attach(Type     =>'image/gif',
				 Path     =>'aaa000123.gif',
				 Filename =>'logo.gif'
				 );

	$text = $msg->as_string;

MIME::Lite also includes a method for sending these things.

	$msg->send;

This defaults to using L<sendmail> but can be customized to use
SMTP via L<Net::SMTP>.

=head2 How do I read mail?

While you could use the Mail::Folder module from CPAN (part of the
MailFolder package) or the Mail::Internet module from CPAN (part
of the MailTools package), often a module is overkill.  Here's a
mail sorter.

	#!/usr/bin/perl

	my(@msgs, @sub);
	my $msgno = -1;
	$/ = '';                    # paragraph reads
	while (<>) {
		if (/^From /m) {
			/^Subject:\s*(?:Re:\s*)*(.*)/mi;
			$sub[++$msgno] = lc($1) || '';
		}
		$msgs[$msgno] .= $_;
	}
	for my $i (sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msgs)) {
		print $msgs[$i];
	}

Or more succinctly,

	#!/usr/bin/perl -n00
	# bysub2 - awkish sort-by-subject
	BEGIN { $msgno = -1 }
	$sub[++$msgno] = (/^Subject:\s*(?:Re:\s*)*(.*)/mi)[0] if /^From/m;
	$msg[$msgno] .= $_;
	END { print @msg[ sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msg) ] }

=head2 Wie kann ich meinen Hostnamen, Domainnamen oder IP-Adresse herausfinden?
X<hostname, domainname, IP address, host, domain, hostfqdn, inet_ntoa,
gethostbyname, Socket, Net::Domain, Sys::Hostname>

(beigetragen von brian d foy)

The Net::Domain module, which is part of the standard distribution starting
in perl5.7.3, can get you the fully qualified domain name (FQDN), the host
name, or the domain name.

	use Net::Domain qw(hostname hostfqdn hostdomain);

	my $host = hostfqdn();

The C<Sys::Hostname> module, included in the standard distribution since
perl5.6, can also get the hostname.

	use Sys::Hostname;

	$host = hostname();

To get the IP address, you can use the C<gethostbyname> built-in function
to turn the name into a number. To turn that number into the dotted octet
form (a.b.c.d) that most people expect, use the C<inet_ntoa> function
from the <Socket> module, which also comes with perl.

	use Socket;

	my $address = inet_ntoa(
		scalar gethostbyname( $host || 'localhost' )
		);

=head2 Wie kann ich einen News-Artikel oder die aktive Newsgroup holen?

Benutze das Net::NNTP- oder News::NNTPClient-Modul, die es beide auf dem
CPAN gibt. Das macht Aufgabe wie das holen der Newsgroup-Liste so einfach wie

	perl -MNews::NNTPClient
	  -e 'print News::NNTPClient->new->list("newsgroups")'

=head2 Wie kann ich eine Datei per FTP holen/hochladen?

LWP::Simple (auf dem CPAN verfügbar) kann Dateien holen aber nicht hochladen.
Net::FTP (ebenfalls auf dem CPAN verfügbar) is komplexer kann aber sowohl Dateien
hochladen als auch holen.

=head2 Wie kann ich RPC in Perl verwenden?

(beigetragen von brian d foy)

Benutze eines der RPC-Module, die Du auf CPAN finden kannst (
http://search.cpan.org/search?query=RPC&mode=all ).

=head1 REVISION

Revision: $Revision$

Datum: $Date$

Für Details über Versionskontrolle und Verfügbarkeit siehe L<perlfaq>.

=head1 AUTOR UND COPYRIGHT

Copyright (c) 1997-2009 Tom Christiansen, Nathan Torkington und andere
Autoren wie genannt. Alle Rechte vorbehalten.

Diese Dokument ist frei; Du kannst es unter den gleichen Bedingungen wie
Perl selbst weiterverteilen und/oder verändern.

Unabhängig von der Verteilung, sind alle Code-Beispiele Gemeingut. Dir wird 
erlaubt und du wirst ermutigt, sie und beliebige davon abgeleitete in deinen 
Programmen zum Spaß oder für Profit zu verwenden. 
Ein einfacher Kommentar im Code, der die FAQ würdigt, wäre nett, ist aber 
nicht erforderlich. 

Übersetzung von Renée Bäcker
